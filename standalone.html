<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Dungeon Adventure</title>

    <!-- Enable cross-origin isolation for GitHub Pages (enables SharedArrayBuffer for input()) -->
    <script src="./coi-serviceworker.js"></script>

    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: #000;
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        py-terminal {
            display: block !important;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: #000 !important;
            background-color: #000 !important;
            color: #00ff00;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 10px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            box-sizing: border-box;
            /* Smooth scrolling */
            scroll-behavior: smooth;
            /* Prevent pull-to-refresh */
            touch-action: pan-y;
        }

        /* Force all containers within terminal to have black background */
        py-terminal div,
        py-terminal pre,
        py-terminal code {
            background: #000 !important;
            background-color: #000 !important;
        }

        py-terminal::-webkit-scrollbar {
            width: 8px;
        }

        py-terminal::-webkit-scrollbar-track {
            background: #000;
        }

        py-terminal::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        /* Mobile optimizations */
        @media screen and (max-width: 768px) {
            py-terminal {
                /* Use dynamic viewport height for keyboard handling */
                height: 100dvh;
                /* Smaller font on mobile */
                font-size: 13px;
                /* Less padding on mobile */
                padding: 8px;
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }

            /* Hide scrollbar on mobile for cleaner look */
            py-terminal::-webkit-scrollbar {
                display: none;
            }
        }

        /* Prevent text selection jank on mobile */
        @media (hover: none) and (pointer: coarse) {
            py-terminal {
                -webkit-user-select: text;
                user-select: text;
                -webkit-touch-callout: none;
            }
        }
    </style>
</head>
<body>
    <py-terminal></py-terminal>

    <!-- PyScript Configuration -->
    <py-config>
        [[fetch]]
        files = [
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/monsters.py",
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/weapons.py",
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/spells.py",
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/items.py",
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/dungeon.py",
            "https://raw.githubusercontent.com/zdodson94/dungeon-adventure/main/player.py",
        ]
    </py-config>

    <script type="py" terminal worker>
import sys
import asyncio
from pyodide.http import pyfetch
from js import document

# Minimal output during loading

GITHUB_USER = "zdodson94"
GITHUB_REPO = "dungeon-adventure"
GITHUB_BRANCH = "main"

BASE_URL = f"https://raw.githubusercontent.com/{GITHUB_USER}/{GITHUB_REPO}/{GITHUB_BRANCH}"

async def fetch_file(filename):
    """Fetch a Python file from GitHub"""
    url = f"{BASE_URL}/{filename}"
    response = await pyfetch(url)
    if response.status == 200:
        content = await response.string()
        return content
    else:
        raise Exception(f"Failed to fetch {filename}: HTTP {response.status}")

# Create browser-compatible versions of modules

# Mock print module (disable slow print for browser)
class PrintModule:
    options = {'text delay': 0, 'autosave': False}

    @staticmethod
    def slow_print(msg):
        # Just print the message (replaces slow print effect with instant print)
        print(msg)

    @staticmethod
    def slow_input(msg, fn=str, shorthand_map={}, allowable_inputs=[]):
        # Don't print the prompt - PyScript terminal echoes it automatically
        # The original game calls slow_print(msg) but in browser this creates duplicates
        while True:
            inp = input(msg).lower().strip()
            try:
                inp = fn(inp)
            except:
                PrintModule.slow_print(f'Input "{inp}" is not allowed! Try again...')
                continue
            if shorthand_map:
                inp = shorthand_map.get(inp, inp)
            if allowable_inputs and inp not in allowable_inputs:
                PrintModule.slow_print(f'Input "{inp}" is not allowed! Try again...')
                continue
            return inp

    @staticmethod
    def set_options(*args):
        print("Options menu disabled in browser version")

    @staticmethod
    def set_options_from_dict(opt_dict):
        pass

sys.modules['print'] = PrintModule()

# Mock save module (no file I/O in browser)
class SaveModule:
    save_path = "./saves"
    options = {'autosave': False}

    @staticmethod
    def save_game(*args, **kwargs):
        print("⚠️  Save disabled in browser version")

    @staticmethod
    def save_data(*args):
        print("⚠️  Save disabled in browser version")

    @staticmethod
    def load_data(path):
        return None, None, {}

    @staticmethod
    def print_existing_save_files():
        print("⚠️  Save/load disabled in browser version")

    @staticmethod
    def get_existing_save_files():
        return []

    @staticmethod
    def autosave(*args):
        pass

    @staticmethod
    def edit_save_data(*args):
        pass

    @staticmethod
    def set_options_from_dict(opt_dict):
        pass

sys.modules['save'] = SaveModule()

# Main async function
async def main():
    try:
        print("Starting to load game files...")

        # Fetch all files in dependency order
        files_to_load = [
            ('items.py', 'items'),        # No dependencies
            ('weapons.py', 'weapons'),    # Depends on items
            ('spells.py', 'spells'),      # No dependencies
            ('monsters.py', 'monsters'),  # No dependencies
            ('dungeon.py', 'dungeon'),    # Depends on monsters, items, weapons, spells
            ('player.py', 'player'),      # Depends on everything
        ]

        for filename, module_name in files_to_load:
            print(f"Fetching {filename}...")
            code = await fetch_file(filename)
            print(f"Loaded {filename}")

            # Execute the code and create a module
            import types
            module = types.ModuleType(module_name)
            sys.modules[module_name] = module
            exec(code, module.__dict__)

        # Now import them
        print("Importing modules...")
        import monsters
        import weapons
        import spells
        import items
        import dungeon
        import player
        print("All modules loaded successfully!")

        print("Ready to start game!\n")

        # Game loop (simplified for browser - no save/load)
        labyrinth_size = PrintModule.slow_input(
            'What size of labyrinth would you like? [3 - 7]',
            int,
            allowable_inputs=list(range(3, 8))
        )

        the_labyrinth = dungeon.Labyrinth(labyrinth_size)

        player_class = PrintModule.slow_input(
            'Player class [(f)ighter or (m)age]:',
            shorthand_map={'f': 'fighter', 'm': 'mage'},
            allowable_inputs=['fighter', 'mage']
        )

        if player_class == 'fighter':
            the_player = player.Fighter(the_labyrinth.start_location)
        else:
            the_player = player.Mage(the_labyrinth.start_location)

        # Game loop
        print('You wake up in a dimly lit room.')
        print('You sense a darkness that you must destroy...')
        the_labyrinth.get_room(the_player.location).describe(the_player)

        while any(room.monsters for room in the_labyrinth.map.ravel()):
            the_player.action(the_labyrinth)

        print('\nYou lit up the dark! A portal to home opens...you win!')
        print('\nRefresh the page to play again.')

    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()

# Run the main function
import asyncio
asyncio.ensure_future(main())
    </script>

    <script>
        // Mobile keyboard handling with viewport-based padding adjustment
        let terminal;
        let initialHeight = window.innerHeight;

        function updateTerminalPadding() {
            if (!terminal) return;

            let keyboardHeight = 0;

            // Try Visual Viewport API first (more reliable)
            if (window.visualViewport) {
                const viewportHeight = window.visualViewport.height;
                const windowHeight = window.innerHeight;
                keyboardHeight = Math.max(0, windowHeight - viewportHeight);
            } else {
                // Fallback: compare current height to initial height
                keyboardHeight = Math.max(0, initialHeight - window.innerHeight);
            }

            // If keyboard is open (significant height difference)
            if (keyboardHeight > 50) {
                // Add bottom padding equal to keyboard height
                terminal.style.paddingBottom = `${keyboardHeight + 40}px !important`;

                // Scroll to bottom after a delay
                setTimeout(() => {
                    terminal.scrollTop = terminal.scrollHeight;
                }, 100);
            } else {
                // Reset to default mobile/desktop padding
                if (window.innerWidth <= 768) {
                    terminal.style.paddingBottom = 'max(20px, env(safe-area-inset-bottom))';
                } else {
                    terminal.style.paddingBottom = 'max(10px, env(safe-area-inset-bottom))';
                }
            }
        }

        function ensureInputVisible() {
            if (!terminal) return;

            const inputs = terminal.querySelectorAll('input');
            if (inputs.length > 0) {
                const lastInput = inputs[inputs.length - 1];

                // Scroll terminal to bottom
                requestAnimationFrame(() => {
                    terminal.scrollTop = terminal.scrollHeight;
                });

                // Also scroll input into view
                setTimeout(() => {
                    lastInput.scrollIntoView({
                        behavior: 'instant',
                        block: 'end'
                    });
                }, 150);
            }
        }

        function initTerminal() {
            terminal = document.querySelector('py-terminal');
            if (!terminal) {
                setTimeout(initTerminal, 100);
                return;
            }

            // Watch for content changes
            const observer = new MutationObserver(() => {
                setTimeout(() => {
                    ensureInputVisible();
                }, 50);
            });

            observer.observe(terminal, {
                childList: true,
                subtree: true
            });

            // Visual Viewport API - best for mobile keyboard detection
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    updateTerminalPadding();
                    setTimeout(ensureInputVisible, 200);
                });
            }

            // Regular window resize as fallback
            window.addEventListener('resize', () => {
                updateTerminalPadding();
                setTimeout(ensureInputVisible, 200);
            });

            // Watch for input focus - trigger keyboard adjustment
            terminal.addEventListener('focusin', (e) => {
                if (e.target.tagName === 'INPUT') {
                    // Multiple attempts to handle keyboard opening
                    setTimeout(updateTerminalPadding, 100);
                    setTimeout(updateTerminalPadding, 300);
                    setTimeout(updateTerminalPadding, 500);
                    setTimeout(() => {
                        updateTerminalPadding();
                        ensureInputVisible();
                    }, 700);
                }
            });

            // Initial update
            updateTerminalPadding();
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initTerminal);
        } else {
            initTerminal();
        }
    </script>
</body>
</html>
